# C# avançado e _design patterns_

1 - Considera a classe
[`ZipFile`](https://docs.microsoft.com/dotnet/api/system.io.compression.zipfile).
Que _design pattern_ pattern está a ser implementado por esta classe. Justifica
a tua resposta.

> [Soluções](../solucoes/04/001.md)

---

2 - Usando as interfaces nativas do C# para implementação do _Observer
pattern_, nomeadamente
[`IObserver<T>`](https://docs.microsoft.com/dotnet/api/system.iobserver-1) e
[`IObservable<T>`](https://docs.microsoft.com/dotnet/api/system.iobservable-1),
implementa:

1.  Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
    de modo a que não apareça no ecrã) e notifique os observadores cada vez que
    uma tecla é premida.
2.  Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla
    'R'`).
3.  Um observador que guarde o carácter associado à tecla num ficheiro (em modo
    _append_).

O programa deve terminar quando for pressionada a tecla _Escape_.

> [Soluções](../solucoes/04/002.md)

---

3 - Resolve o exercício anterior com recurso a eventos.

> [Soluções](../solucoes/04/003.md)

---

4 - Cria os seguintes métodos de extensão para a classe
[`string`](https://docs.microsoft.com/dotnet/api/system.string):

1.  Método que conta o número de palavras numa _string_. Podes usar o método
[`Split()`](https://docs.microsoft.com/dotnet/api/system.string.split) para
dividir a _string_ em várias palavras, mas certifica-te que todos os caracteres
de _whitespace_ (i.e. espaços, tabs, _new lines_, etc) são usados como
separadores de palavras (estuda a documentação do método de modo para
perceberes como). Deves ainda ignorar palavras com comprimento zero.
2.  Método que conte o número de frases numa _string_. Podes assumir que uma
frase termina com um ponto final. Frases de comprimento zero ou só com
_whitespace_ não devem ser contadas.
3.  Método que conte o número de parágrafos numa _string_. Podes assumir que um
parágrafo termina com uma nova linha (carácter `\n`). Parágrafos com
comprimento zero ou só com _whitespace_ não devem ser contados.

Para testares os métodos, cria um programa que conte as palavras, frases e
parágrafos num ficheiro de texto, cujo nome deve ser passado como argumento na
linha de comandos. Neste programa deves apanhar e tratar todas as excepções que
possam ser lançadas pelo código de leitura do ficheiro.

> [Soluções](../solucoes/04/004.md)

---

5 - Cria um programa que apresente as seguintes estatísticas sobre um projeto
em C#:

1.  Número de linhas de código
2.  Número de linhas em branco (apenas _whitespace_)
3.  Número de linhas que são comentários (i.e. linhas que começam com `//`,
    ignorando comentários do estilo `/* ... */`)

Para o efeito deves criar três métodos de extensão apropriados com os nomes
`IsLineOfCode()`, `IsBlank()` e `IsComment()`, que devolvem um booleano
indicando se a linha (_string_) é do tipo em questão.

O programa deve receber como argumento da linha de comando uma pasta ou um
nome de ficheiro. Se for indicada uma pasta, o programa deve indicar a
estatística global para todos os ficheiros `.cs` na pasta e respetivas
sub-pastas. Caso seja indicado um ficheiro, o programa deve certificar-se que o
mesmo tem extensão `.cs` e mostrar as estatísticas apenas para esse ficheiro.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/005.md)

---

6 - Considera o
[exercício 7](https://github.com/VideojogosLusofona/lp2_2018_aulas/tree/master/Aula07/Exercicio7)
da
[aula 7](https://secure.grupolusofona.pt/ulht/moodle/mod/resource/view.php?id=158347).
Implementa um sistema de _achievements_ para o jogo. O sistema de _achivements_
deve ter as seguintes responsabilidades:

*   Conter uma referência para cada _achievement_ possível no jogo.
*   Cada uma dessas referências deve indicar se o respetivo _achievement_ já
    foi alcançado ou não, ou que percentagem ou partes do _achievement_ já
    foram completadas.
*   Registar um ou mais métodos em eventos pré-existentes que possam significar
    um _achievement_. No caso de eventos do tipo
    [`UnityEvent`](https://docs.unity3d.com/Manual/UnityEvents.html), o método
    ou métodos deve/devem ser registados de forma programática (no código) e
    não no editor. O método ou métodos em questão deve/devem verificar se o
    evento corresponde à completação parcial ou total de um _achievement_, e em
    caso afirmativo atualizar a respetiva referência ao mesmo.
*   Cada vez que um _achievement_ for alcançado, deve ser mostrada uma frase a
    verde na parte inferior da área de jogo, indicando o título do
    _achievement_ em questão e a percentagem de _achievements_ completados.

Inicialmente devem ser contemplados os seguintes  _achievements_:

*   **Gotcha** - Apanhar um alvo.
*   **Outlaw** - Ultrapassar o limite de velocidade.
*   **Persistent** - Apanhar 10 alvos.
*   **Bouncer** - Bater nas 4 paredes.

O sistema de _achievements_ deve ser implementado de acordo com as as melhores
práticas de design de classes e _design patterns_, tal que seja simples
adicionar mais _achievements_ posteriormente.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/006.md)

---

7 - Simplifica ao máximo a seguinte _struct_ usando lambdas e eventualmente
operadores ternários:

```cs
public struct GameMap
{
    private float topScore;
    private int gamesPlayed;
    private int gamesWon;

    public string Name { get; }
    public string Filename { get; }
    public float SuccessRate
    {
        get {
            if (gamesPlayed == 0)
                return 0f;
            else
                return gamesWon / (float) gamesPlayed;
        }
    }
    public float TopScore {
        get
        {
            return topScore;
        }
        set
        {
            if (value > topScore)
            {
                topScore = value;
            }
        }
    }

    public GameMap(string name, string filename)
    {
        Name = name;
        Filename = filename;
        gamesPlayed = 0;
        gamesWon = 0;
        topScore = 0;
    }

    public void GamePlayed(bool won)
    {
        gamesPlayed++;
        if (won)
        {
            gamesWon++;
        }
    }
}
```

> [Soluções](../solucoes/04/007.md)

---

8 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Bullet
{
    private float calibre;
    public float Calibre
    {
        get { return calibre; }
        set { if (value < 0.1f) calibre = 0.1f; else calibre = value; }
    }
}
```

```cs
public class Weapon
{
    public float Value { get; }
    public Weapon(float value) { Value = value; }
}
```

```cs
public class Gun : Weapon
{
    private Bullet[] bullets;
    public Gun(float value, int numBullets, float calibre) : base(value)
    {
        bullets = new Bullet[numBullets];
        for (int i = 0; i < numBullets; i++)
        {
            bullets[i] = new Bullet() { Calibre = calibre };
        }
    }
}
```

> [Soluções](../solucoes/04/008.md)

---

9 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Passenger
{
    private double weight;
    public double Weight
    {
        get { return weight; }
        set { if (value < 5) weight = 5; else weight = value; }
    }
}
```

```cs
public class Vehicle
{
    public double Value { get; }
    public Vehicle(double value) { Value = value; }
}
```

```cs
public class Car : Vehicle
{
    private Passenger[] passengers;
    public Car(double value, int numPassengers, float avgWeight) : base(value)
    {
        Random r = new Random();
        passengers = new Passenger[numPassengers];
        for (int i = 0; i < numPassengers; i++)
        {
            passengers[i] = new Passenger()
            {
                Weight = avgWeight + r.Next(-10, 10)
            };
        }
    }
}
```

> [Soluções](../solucoes/04/009.md)

---

10 - Considera a seguinte classe:

```cs
public static class VectorOperations
{
    // Normalized direction between two game objects
    public static Vector2 Direction(Vector2 from, Vector2 to)
    {
        return (to - from) / (to - from).magnitude;
    }

    // Distance between two game objects
    public static float Distance(Vector2 obj1, Vector2 obj2)
    {
        return (obj1 - obj2).magnitude;
    }

    // Convert angle in degrees into normalized vector
    public static Vector2 Deg2Vec(float angle)
    {
        float angleRad = angle * Mathf.Deg2Rad;
        return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad));
    }

    // Determine angle of vector in degrees
    public static float Vec2Deg(Vector2 vector)
    {
        return Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    }
}
```

Responde às seguintes questões:

1.  Simplifica os métodos usando lambas.
2.  Declara, para cada método, um _delegate_ personalizado compatível.
3.  Indica, para cada método, um _delegate_ pré-definido do C# que seja
    compatível.
4.  Assumindo que estás num método noutra classe, escreve quatro linhas de
    código nas quais declaras quatro variáveis do tipo _delegate_ pré-definido
    que indicaste na alínea anterior, atribuindo-lhes o respetivo método
    compatível.
5.  Repete a alínea anterior mas considerando os _delegates_ personalizados que
    declaraste na alínea 2 (e não os _delegates_ pré-definidos do C#).

> [Soluções](../solucoes/04/010.md)

---

11 - Considera o seguinte código:

```cs
public class EventProducer
{
    public string Str { get; private set; }
    public int N { get; private set; }

    protected virtual void OnProducedEvent()
    {
        ProducedEvent?.Invoke(Str, N);
    }
    public event Action<string, int> ProducedEvent;
}
```

O código anterior funciona perfeitamente, mas tens um patrão chato que exige
que uses _delegates_ propositadamente criados para uso em eventos. Assim sendo,
substitui o _delegate_ pré-definido
[`Action<T1,T2>`](https://docs.microsoft.com/dotnet/api/system.action-2)
pelo _delegate_ pré-definido
[`EventHandler<TEventArgs>`](https://docs.microsoft.com/dotnet/api/system.eventhandler-1),
alterando o código em conformidade. Poderá ser necessário criar uma classe
adicional.

> [Soluções](../solucoes/04/011.md)

---

12 - Compara a documentação dos _delegates_ pré-definidos
[`Action`](https://docs.microsoft.com/dotnet/api/system.action)
e
[`ThreadStart`](https://docs.microsoft.com/dotnet/api/system.threading.threadstart).
Porque razão não é possível utilizar o delegate `Action` em _threads_, tendo em
conta que ambos os _delegates_ devolvem `void` e não aceitam parâmetros.

> [Soluções](../solucoes/04/012.md)

---

13 - Qual é ou quais são as diferenças entre _delegates_ e eventos no C#?

> [Soluções](../solucoes/04/013.md)

---

14 - Que _design pattern_ é explicitamente implementado pelos eventos do C#?
Explica o teu raciocínio.

> [Soluções](../solucoes/04/014.md)

---

15 - O ficheiro [`015.tsv`](04/015.tsv) contém dados, separados por _tabs_,
sobre todos os exoplanetas conhecidos (a 30-11-2018). Cada linha contém a
seguinte informação:

*   ID do planeta
*   Nome do sistema estelar a que o planeta pertence
*   Letra do planeta dentro do seu sistema estelar
*   Nome do planeta
*   Método de deteção do planeta
*   Período orbital em dias
*   Distância em _parsecs_
*   Temperatura em Kelvins
*   Telescópio responsável pela descoberta

As linhas que começam com o carácter `#` são comentários e devem ser ignoradas.

Cria um projeto no Visual Studio que respeite os seguintes requisitos:

1.  Enumeração que contenha os diferentes métodos de descoberta de exoplanetas.
2.  _Struct_ imutável `Planet`, que contém toda a informação sobre um planeta
    sob a forma de propriedades só de leitura e um construtor para inicializar
    essas mesmas propriedades. Cada propriedade deve ser do tipo apropriado ao
    dado que reporta.
3.  A _struct_ `Planet` deve ter _overrides_ de `GetHashCode()` e `Equals()` de
    modo a que a igualdade entre planetas dependa apenas do respetivo ID.
4.  Classe `PlanetLoader`, com um único método `LoadPlanets()`. Este método
    aceita um parâmetro o nome de ficheiro que contém os dados sobre os
    planetas, devolvendo um `IEnumerable<Planet>` com todos os planetas lidos.
    Tanto a classe como o método devem ser `static`.
5.  Classe `Program`, com método `Main()`, no qual é invocado o método
    `LoadPlanets()`, e posteriormente mostrada no ecrã a seguinte informação,
    obtida com o uso de Lambdas e LINQ (sintaxe fluente ou expressões _query_,
    sem preferência):
    *   Número de exoplanetas existentes.
    *   Método mais comum de deteção.
    *   Máximo de exoplanetas em torno da mesma estrela.
    *   Média do período orbital.
    *   Planeta mais longíquo (e a respetiva distância).
    *   Média da temperatura dos planetas cuja estrela tem pelo menos dois
        planetas.
    *   Telescópio com menos descobertas.
6.  Todas as possíveis exceções devem ser tratadas ao nível da classe
    `Program`.
7.  Todas as classes e respetivos membros devem estar documentados com
    comentários XML.

> [Soluções](../solucoes/04/015.md)

---

16 - Desenha o diagrama UML completo do problema anterior (não requer resolução
     do problema).

> [Soluções](../solucoes/04/016.md)

---

17 - Considera o seguinte método:

```cs
public bool HasWeapons(int npcId)
{
    return npcs[npcId].Bag.Any(item => item.Category == ItemCategory.Weapon);
}
```

Responde às seguintes questões:

1.  Qual é a tua interpretação sobre o que o código está a fazer?
2.  Qual é o tipo da propriedade `Category`?
3.  Que princípio ou princípios de design estão a ser violados neste código?
    Que problemas poderão ocorrer se algum dos objetos manipulados for `null`?
4.  Simplifica o código usando operadores para tratamento de `null`s e
    expressões Lambda.

> [Soluções](../solucoes/04/017.md)

---

18 - O teu jogo é _shooter_ de sucesso, e a classe base de todas as armas é
`Weapon`, cuja interface está definida da seguinte forma:

```cs
interface IWeapon
{
    // This property is true if weapon is in alternate firing mode, false
    // otherwise
    bool IsAlternate { get; }

    // Reload the weapon
    void Reload();

    // Shoot the weapon, return true if any rounds left to shoot in current
    // firing mode, false otherwise
    bool Shoot();

    // Switch between main and alternate firing modes
    void SwitchFireMode();
}
```

Os teus investidores exigem um DLC que inclua _melee weapons_, ou seja, armas
para combate corpo a corpo. Os investidores tomaram a liberdade de adquirir um
pacote de _assets_ para esse fim, e querem integra-lo no jogo. A interface das
_melee weapons_ é a seguinte:

```cs
interface IMelee
{
    // Attacks return true if they hit opponent
    bool AttackFromAbove();
    bool AttackFromBelow();
    bool AttackFromTheLeft();
    bool AttackFromTheRight();
}
```

Como podes resolver este problema? Escreve código para esse fim e justifica as
tuas opções.

> [Soluções](../solucoes/04/018.md)

---

19 - Considera a seguinte enumeração:

```cs
public enum Quadrilateral { Square, Rectangle, Trapezoid, Rhombus, Kite }
```

Escreve um programa com duas _threads_. Uma das _threads_ coloca aleatoriamente
e com igual probabilidade itens desta enumeração numa pilha (_stack_)
_thread-safe_, com intervalos de colocação aleatórios entre 0 a 8 segundos. A
outra _thread_, que pode ser a _thread_ principal, retira todos os itens em
intervalos regulares de 10 segundos.

Após a colocação de um item, existe uma probabilidade de 5% da primeira
_thread_ decidir terminar o programa. Para o efeito, esta _thread_ coloca
`null` na pilha e finaliza a sua execução. A _thread_ principal, ao capturar
este `null` durante o desempilhamento, também finaliza a sua execução. Atenção
que as enumerações são tipos de valor e não aceitam diretamente o valor `null`.

A visualização do programa deve ser feita em modo de consola, com a consola
dividida em duas colunas:

1.  Os itens colocados na pilha pela primeira _thread_ são indicados na
    primeira coluna, até um máximo de 30 itens. Após a colocação de 30 itens,
    a coluna deve ser limpa e a indicação dos itens deve recomeçar no início da
    coluna.
2.  Quando a _thread_ principal retira os itens da pilha, deve indicar os itens
    retirados na segunda coluna. Antes de começar novo desempilhamento, a
    _thread_ deve limpar a coluna.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_. Quaisquer
variáveis de tipos não _thread-safe_ partilhadas entre _threads_ devem estar
guardadas por _locks_.

> [Soluções](../solucoes/04/019.md)

---

20 - Implementa um jogo em modo consola, do estilo _Space Invaders_, no qual
o jogador controla uma defesa anti-aérea `^` que dispara um tiro `|` com
frequência máxima de um tiro por segundo. O tiro viaja à velocidade de 1
carácter de consola por cada 150 milisegundos. Deve também existir um alvo `O`,
que é destruído quando é atingido por um tiro, reaparecendo um novo alvo após 1
segundo.

O jogo deve ser implementado com as seguintes _threads_, que comunicam entre si
através de instâncias da fila _thread-safe_
[`BlockingCollection<T>`](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.blockingcollection-1):

1.  A **_Thread_ de _input_** lê do teclado e envia as teclas lidas para uma
    fila _thread-safe_. São reconhecidas apenas as teclas _Espaço_, _Seta
    direita_, _Seta esquerda_ e _Escape_. As restantes teclas são ignoradas. A
    _thread_ deve terminar a sua execução quando detetar a tecla_Escape_,
    enviando a mesma para a fila antes de terminar.
2.  A **_Thread_ Jogador** controla o jogador `^`, obtendo as teclas da fila. O
    jogador pode andar para a esquerda e para a direita e disparar tiros `|`
    quando deteta a tecla _Espaço_. O jogador não pode disparar mais do que um
    tiro por segundo, devendo ignorar a tecla _Espaço_ durante esse período.
    Para disparar o tiro, a _thread_ Jogador lança uma nova _thread_ por cada
    tiro disparado, passando-lhe a posição atual do jogador. A _thread_ Jogador
    não tem de esperar (fazer _join_) das _threads_ de disparo, e termina
    quando detetar a tecla _Escape_ na fila _thread-safe_.
3.  Cada **_Thread_ de disparo** é responsável pela renderização e deteção de
    colisão de um tiro. Cada tiro sobe na vertical à velocidade de 1 caráter de
    consola por 150 milisegundos. Cada uma destas _threads_ termina quando o
    respetivo tiro desaparece do ecrã ou quando o mesmo colide com o alvo `O`.
    Neste último caso, antes de terminar, a _thread_ deve: a) retirar o alvo
    destruído do ecrã; b) esperar 1 segundo; e, c) colocar aleatoriamente um
    novo alvo no ecrã.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_. Quaisquer
variáveis de tipos não _thread-safe_ partilhadas entre _threads_ devem estar
guardadas por _locks_.

> [Soluções](../solucoes/04/020.md)

---

21 - Cria uma _facade_ para o
[sistema de _input_ do Unity](https://docs.unity3d.com/ScriptReference/Input.html)
com um único método que devolve um
[`Vector2`](https://docs.unity3d.com/ScriptReference/Vector2.html). Esta
_facade_ deve contemplar _input_ de teclado, rato e controlador, e o `Vector2`
devolvido deve representar a direção do movimento num plano 2D.

Para testar a _facade_, cria uma _scene_ contendo um elemento
[`UI.Text`](https://docs.unity3d.com/ScriptReference/UI.Text.html) que mostre
o valor do vetor em cada momento

_Nota:_ A pasta do projeto Unity deve incluir este ficheiro
[`.gitignore`](https://github.com/VideojogosLusofona/lp2_2018_aulas/blob/master/Aula07/Exercicio7/.gitignore).

> [Soluções](../solucoes/04/021.md)

---

22 - Cria as seguintes classes:

*   Classe `AddManager`, com uma propriedade só de leitura de nome `Total` do
    tipo `int` (suportada numa variável de instância privada de nome `total`), e
    com um método `AddToTotal()`, que aceita um inteiro e adiciona-o à variável
    `total`. Esta classe deve ser um _singleton_ com inicialização _lazy_, e
    tanto a sua inicialização como a modificação da variável `total` (dentro do
    método `AddToTotal()`) devem ser _thread-safe_.
*   Classe `Adder`, com o método `LetsAdd()`, que cria e lança uma _thread_ que
    invoca 1000 vezes o método `AddToTotal()` da instância solitária de
    `AddManager`, passando-lhe inteiros aleatórios entre 0 e 100. A classe tem
    também a propriedade auto-implementada `Partial`, na qual a _thread_ guarda
    o total parcial relativo aos inteiros que somou. O método `LetsAdd()`
    retorna a instância da _thread_ criada e lançada.
*   Classe `Program`, com o método `Main()`, no qual: a) são criadas 20
    instâncias de `Adder`; b) é invocado o método `LetsAdd()` em cada delas,
    sendo mantidas referência às _threads_ devolvidas; c) é feita uma espera
    (com _join_) em todas as _threads_ devolvidas; d) é realizada e mostrada no
    ecrã a soma do `Partial` de todas as instâncias de `Adder`; e) é mostrado
    no ecrã o valor `Total` da instância solitária de `AddManager`; e, f) é
    indicado no ecrã se as somas são iguais ou não.

Nota que, para o programa estar correto, as somas devem ser sempre iguais.

> [Soluções](../solucoes/04/022.md)

---

23 - Desenha o diagrama UML completo do problema anterior (não é necessário
resolução do mesmo).

> [Soluções](../solucoes/04/023.md)

---

24 - Considera um jogo _tile-based_, em que cada _tile_ tem as seguintes
propriedades:

*   `DefensePoints` - Bónus de defesa (DEF)
*   `EssentialPoints` - Bónus de extração de bens essenciais (ESS)
*   `LuxuryPoints` - Bónus de extração de bens de luxo (LUX)

Inicialmente existem os seguintes tipos base de _tile_ com as características
indicadas:

*   _Grassland_: DEF = 0, ESS = 3, LUX = 0
*   _Desert_: DEF = -1, ESS = 0, LUX = 1
*   _Jungle_: DEF = 1, ESS = 1, LUX = 1
*   _Mountain_: DEF = 3, ESS = 1, LUX = 1

Além disso, estes _tiles_ pode ainda ter especializações particulares que podem
alterar as suas características conforme indicado:

*   _Vineyard_: ESS+1, LUX+1
*   _Sheep_: ESS+3
*   _Gold_: LUX+4
*   _Fortress_: DEF+3, LUX-1

Propõe uma solução para este problema, composta pelos seguintes elementos:

*   Diagrama UML completo.
*   Código C#, no qual se inclui uma classe `Program` para testar o código.

> [Soluções](../solucoes/04/024.md)

---

25 - Considera a seguinte classe C# para uso no Unity:

```cs
public class PlayerStats : MonoBehaviour {

    private Player player;

    private void Awake()
    {
        player = GameObject.FindWithTag("Player").GetComponent<Player>();
    }

    private void UpdatePowerUpStats(float powerUpMagnitude)
    {
        // Código que atualiza as estatísticas de power-ups do player
    }
}
```

Responde às seguintes questões:

1.  Indica um _delegate_ pré-definido do C# compatível com o método
    `UpdatePowerUpStats`.
2.  Considera que a classe `Player` tem um evento nativo do C# chamado
    `PickedUpAPowerUp`. Completa a classe `PlayerStats` de modo a que o
    método `UpdatePowerUpStats` seja notificado desse evento quando a instância
    de `Player` estiver ativa.
3.  Responde à questão anterior considerando que o evento `PickedUpAPowerUp` é
    do tipo `UnityEvent<float>`.

> [Soluções](../solucoes/04/025.md)

---

26 - Descreve, por palavras tuas, três dos principais problemas no uso de
_singletons_. Qual é a principal vantagem no uso deste _design pattern_?

> [Soluções](../solucoes/04/026.md)

---

27 -  Considera a seguinte enumeração:

```cs
enum Monster { Troll, Ogre, Elf, Demon, Vampire, Werewolf, Minion }
```

Responde às seguintes questões:

1.  Declara uma lista de `Monster` na qual seja possível também introduzir
    `nulls`.
2.  Assume que a variável `monst` é do tipo `Monster`. Escreve uma linha de
    código onde atribuis à variável `monst` o valor do primeiro elemento da
    lista da alínea anterior, tendo em conta que se este valor for `null`, o
    valor efetivamente a atribuir será `Minion`.
3.  Escreve o código de um método que receba a lista da primeira alínea e
    devolva um inteiro indicando quantos `nulls` existem na lista. O método
    deve ser o mais compacto possível, fazendo uso Lambdas e LINQ.

> [Soluções](../solucoes/04/027.md)

---

28 - Considera o método com assinatura `void DoStuff()`. Assumindo que estás
noutro método da mesma classe, escreve código para:

1.  Declarar 100 _threads_ que executem o método `DoStuff()`.
2.  Iniciar as 100 _threads_ de modo a que executem em paralelo.
3.  Esperar que a execução dessas mesmas _threads_ termine.

> [Soluções](../solucoes/04/028.md)

---

29 - Considera a seguinte classe:

```cs
class ParallelCalculation
{
    private double result;
    public void AddToResult(double toAdd)
    {
        result += toAdd;
    }
    // Other code
    public event Action Bingo;
}
```

1.  Modifica a classe de modo a que as operações realizadas pelo método
    `AddToResult()` sejam _thread-safe_.
2.  Considera que `pc` é uma instância de `ParallelCalculation`, e que tens um
    método com assinatura `void BingoHandler()`. Escreve uma linha de código na
    qual subscrevas o método `BingoHandler()` no evento `Bingo`.
3.  Escreve o código do método `OnBingo()` da classe `ParallelCalculation`,
    usando as melhores práticas de visibilidade, extensão e tratamento de
    `nulls`.

> [Soluções](../solucoes/04/029.md)

---

30 - Considera o tipo `int` e responde às seguintes questões:

1.  Escreve o código dos seguintes métodos de extensão para `int`, bem como da
    classe que os contém:
    *   `bool IsEven()`: Devolve `true` se inteiro for par, `false` caso
        contrário.
    *   `bool IsZeroOrPositive()`: Devolve `true` se inteiro for zero ou
        positivo, `false` caso contrário.
    *   `bool IsDivisorOf(int otherInt)`: Devolve `true` se inteiro for divisor
        do inteiro passado como argumento, `false` caso contrário.
2.  Considera o inteiro 8. Como invocarias o método `IsDivisorOf(15)` nesse
    valor? E qual seria o resultado?
3.  Considera a variável `setOfInts` do tipo `IEnumerable<int>`. Usando
    expressões Lambda e LINQ, escreve as seguintes expressões:
    *   Expressão que resulte no número (quantidade) de inteiros pares
        existentes em `setOfInts`.
    *   Expressão que resulte num `IEnumerable<int>` só com divisores de 60.
4.  Qual teria de ser o tipo da variável `setOfIntsOrNulls` de modo a que possa
    também conter `nulls`?
5.  Considerando que a variável `setOfIntsorNulls` é do tipo que indicaste na
    alínea anterior, escreve uma expressão, usando expressões Lambda e LINQ,
    que indique se o enumerável contém ou não `nulls`.
6.  Escreve o código para percorrer todos os elementos de `setOfIntsorNulls` e
    efetuar a operação XOR (`^`) de todos os seus valores com a variável
    `xored`, do tipo `int`, assumindo que a mesma foi previamente declarada e
    inicializada a zero. Os `nulls` devem ser considerados como tendo o valor
    zero para efeitos de XOR. Usa, sempre que possível, operadores para
    tratamento de `nulls`.

> [Soluções](../solucoes/04/030.md)

---

31 - Considera a variável `lstStr` do tipo `List<string>`. O tipo
[`List<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1)
tem vários métodos cujo nome começa com `Find`, os quais têm como objetivo encontrar
elementos na lista que obedeçam a um dado predicado. Este predicado fornece a
estratégia de procura na forma de um _delegate_. Responde às seguintes
questões:

1.  Em que _design pattern_ foi inspirada esta forma de procurar elementos numa
    lista?
2.  Usando o método
    [`FindAll()`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.findall),
    escreve uma expressão que resulte numa lista contendo apenas as _strings_
    que contenham a _sub-string_ `"LP2"`, partindo da lista original `lstStr`.

> [Soluções](../solucoes/04/031.md)

---

32 - Resolve a 2ª alínea do exercício anterior usando LINQ.

> [Soluções](../solucoes/04/032.md)

---

33 - Estás a desenvolver um RPG e tens NPCs com três categorias base que os
definem:

*   Movimento
*   Combate
*   Interação (com o jogador)

Podem existir milhares de NPCs diferentes. Para atingir essa diversidade, cada
NPC individual pode utilizar diferentes e complexas estratégias que definem as
suas três categorias base. Para efeitos deste exercício fica uma lista de
alguns dos NPCs que vão aparecer no jogo final, bem como as estratégias que os
definem em cada categoria base:

*   B.J. King: movimento solto, combate confinado, interação agressiva
*   J.P. Morgan: movimento solto, combate _melee_, interação afável
*   M. Faraday: movimento rígido, combate à distância, interação rabugenta
*   J. Austen: movimento gracioso, não combate, interação inteligente
*   A. Frank: movimento gracioso, combate inteligente, interação afável
*   M. Thatcher: movimento rígido, combate confinado, interação agressiva
*   J. Reno: movimento rígido, combate confinado, interação inteligente
*   J. Goodall: movimento solto, combate _melee_, interação inteligente
*   A. Rand: movimento gracioso, combate confinado, interação rabugenta
*   F. Kahlo: movimento gracioso, não combate, interação rabugenta
*   M.L. King: movimento rígido, combate inteligente, interação inteligente
*   D. Gea: movimento solto, combate à distância, interação afável
*   A. Murray: movimento gracioso, combate confinado, interação agressiva
*   L. Bird: movimento solto, combate à distância, interação rabugenta
*   R. Polanski: movimento rígido, combate inteligente, interação inteligente
*   A. Lavigne: movimento gracioso, não combate, interação afável
*   K. Hammett: movimento solto, combate _melee_, interação agressiva

Responde às seguintes questões:

1.  Indica, justificando, um _design pattern_ apropriado para implementar este
    sistema.
2.  Apresenta um diagrama UML com a informação mínima e essencial que demonstre
    como o _design pattern_ indicado na alínea anterior pode ser utilizado para
    implementar este sistema.
3.  Apresenta uma implementação muito simples em C\# deste sistema baseada na
    resposta dada nas alíneas anteriores. As "estratégias complexas" devem ser
    confinadas a simples `Console.WriteLine()`.

_Sugestão:_ Submeter soluções parciais, uma alínea de cada vez, e esperar por
_feedback_ antes de responder à alínea seguinte.

> [Soluções](../solucoes/04/033.md)

---

34 - Cria uma pequena simulação na qual três agentes se movem aleatoriamente
num mundo de dimensão 40x20 toroidal com vizinhança de Moore. Os agentes devem
ter as seguintes características:

| Agente | Carácter | Intervalo mov. |
|--------|----------|----------------|
|      1 |     #    |   0.2 segundos |
|      2 |     $    |   0.5 segundos |
|      3 |     @    |      1 segundo |

A coluna "Intervalo mov." representa o intervalo entre cada movimento de um
agente.

A simulação deve ser implementada usando bons princípios de design de classes,
e o _game loop_ deve ter _update_ fixo e renderização variável.

_Nota:_ A mesma posição do mundo pode conter mais do que um agente, pelo que a
solução deve contemplar este requisito.

> [Soluções](../solucoes/04/034.md)

---

35 - Os [Autómatos Celulares Elementares](https://en.wikipedia.org/wiki/Elementary_cellular_automaton)
(ACEs) são sistemas muito simples mas que produzem padrões muito complexos.
Estes sistemas podem ser representados com um _array_ de booleanos.
Por exemplo, um ACE de tamanho 5 pode ter o seguinte aspeto gráfico:

```
.*..*
```

Neste exemplo o caráter `.` corresponde a `false` e o caráter `*` a `true`. Os
ACEs podem ter novas gerações, que dependem da geração anterior e de uma regra
de geração. Esta regra define como cada célula da nova geração é criada a
partir das suas progenitoras. Mais especificamente, cada célula da nova geração
depende da sua progenitora direta bem como das suas duas vizinhas. E como
sabemos o estado das vizinhas nas extremidades do _array_? Não há problema,
pois podemos considerar o mundo como toroidal. Por exemplo, o vizinho esquerdo
da célula na posição 0 do _array_ é a célula na última posição desse mesmo
_array_.

Existem 256 regras, desde a regra 0 até à regra 255. Para entendermos como a
regra funciona, é necessário converter o valor decimal da mesma em binário. Por
exemplo, na [regra 110](https://en.wikipedia.org/wiki/Rule_110), o valor
decimal 110 corresponde ao valor binário 01101110. Após esta conversão, a regra
110 funciona da seguinte forma para determinar as gerações seguintes:

| Possíveis estados dos progenitores                | 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |
|---------------------------------------------------|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| Novo estado da célula central segundo a regra 110 |  0  |  1  |  1  |  0  |  1  |  1  |  1  |  0  |

Para o exemplo apresentado, `.*..*`, a próxima geração será `**.**`, de acordo
com a seguinte análise:

*   **Célula 0** tem como progenitores `*.*` (101), logo o seu novo valor vai
    ser `*` (1). Devido ao mundo ser toroidal, o progenitor esquerdo é a última
    célula do _array_.
*   **Célula 1** tem como progenitores `.*.` (010), logo o seu valor vai ser
    `*` (1).
*   **Célula 2** tem como progenitores `*..` (100), logo o seu valor vai ser
    `.` (0).
*   **Célula 3** tem como progenitores `..*` (001), logo o seu valor vai ser
    `*` (1).
*   **Célula 4** tem como progenitores `.*.` (010), logo o seu valor vai ser
    `*` (1). Devido ao mundo ser toroidal, o progenitor direito é a primeira
    célula do _array_.

Se deixarmos este ACE correr durante 5 gerações, vai ser impresso no ecrã o
seguinte padrão:

```
.*..*
**.**
.***.
**.*.
*****
```

Desenvolve um programa que solicite ao utilizador a regra a utilizar (0 a 255),
o tamanho do mundo (3 a 100) e o nº de gerações a produzir (3 a 1000), e mostre
no ecrã a evolução do respetivo ACE.

A simulação deve ser implementada usando bons princípios de design de classes,
fazendo obrigatoriamente uso de um _game loop_ (basta ter passo fixo com
sincronização) e de um _double buffer_ (um _array_ para a geração atual e outro
para a próxima geração).

> [Soluções](../solucoes/04/035.md)

---

36 - Implementa a simulação [Langton's ant](https://en.wikipedia.org/wiki/Langton%27s_ant)
fazendo uso de bons princípios de design de classes e _design patterns_
apropriados ao problema. Na resposta deves indicar que princípios e _patterns_
tiveste o cuidado de utilizar.

> [Soluções](../solucoes/04/036.md)

---

37 - Estás a desenvolver um jogo em que os passos seguidos por uma arma ao
realizar um ataque são sempre os mesmos, nomeadamente:

1.  Decrementar munições (dependendo de quantas foram gastas).
2.  Determinar probabilidade de sucesso.
3.  Determinar estrago infligido no inimigo.
4.  Determinar tempo de _cooldown_.

Existem diferentes tipos de arma, que apesar de seguirem estes quatro passos
durante um ataque, poderão personalizá-los de formas distintas. É expectável
que o tempo de _cooldown_ para a maior parte das armas seja zero. Numa primeira
versão o jogo terá duas armas, **_melee_** e **_pistol_**. A arma **_melee_**
tem tempo de _cooldown_ igual a zero.

Responde às seguintes questões:

1.  Que _design pattern_ te parece mais apropriado para resolver este problema?
2.  Apresenta o diagrama UML de uma possível solução, contendo a informação
    mínima e necessária que realce o _pattern_ utilizado.
3.  Apresenta uma implementação mínima da solução proposta na alínea anterior,
    que faça uso de `Console.WriteLine()` para exemplificar os passos do
    algoritmo de combate seguido por cada arma.

> [Soluções](../solucoes/04/037.md)

---

38 - Resolve o problema anterior usando _delegates_. Em que condições é
possível usar _delegates_ para este efeito e qual a vantagem de os usar neste
caso.

> [Soluções](../solucoes/04/038.md)

---

39 - Ainda na sequência dos dois problemas anteriores, considera que as armas
podem realizar apenas alguns dos passos (ações) indicados e sem nenhuma ordem
específica, existindo ainda duas ações adicionais possíveis, em concreto:

1.  Determinar estrago na arma.
2.  Determinar estrago inflingido no próprio jogador, devido por exemplo a
    sobreutilização ou _backfire_.

Responde às seguintes questões:

1.  Que _design pattern_ te parece mais apropriado para resolver este problema?
2.  Apresenta o diagrama UML de uma possível solução, contendo a informação
    mínima e necessária que realce o _pattern_ utilizado.
3.  Apresenta uma implementação mínima da solução proposta na alínea anterior,
    que faça uso de `Console.WriteLine()` para exemplificar os passos do
    algoritmo de combate seguido por cada arma.

> [Soluções](../solucoes/04/039.md)

---

40 - O *Factory method pattern* é um caso específico de outro *pattern*. Indica
qual e explica por palavras tuas as semelhanças e diferenças.

> [Soluções](../solucoes/04/040.md)

---
<!--

41 -

> [Soluções](../solucoes/04/041.md)

---

42 -

> [Soluções](../solucoes/04/042.md)

---

43 -

> [Soluções](../solucoes/04/043.md)

---

44 -

> [Soluções](../solucoes/04/044.md)

---

45 -

> [Soluções](../solucoes/04/045.md)

---

46 -

> [Soluções](../solucoes/04/046.md)

---

47 -

> [Soluções](../solucoes/04/047.md)

---

48 -

> [Soluções](../solucoes/04/048.md)

---

49 -

> [Soluções](../solucoes/04/049.md)

---

50 -

> [Soluções](../solucoes/04/051.md)

---



-->
