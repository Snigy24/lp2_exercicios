## Problema

33 - Estás a desenvolver um RPG e tens NPCs com três categorias base que os
definem:

* Movimento
* Combate
* Interação (com o jogador)

Podem existir milhares de NPCs diferentes. Para atingir essa diversidade, cada
NPC individual pode utilizar diferentes e complexas estratégias que definem as
suas três categorias base. Para efeitos deste exercício fica uma lista de
alguns dos NPCs que vão aparecer no jogo final, bem como as estratégias que os
definem em cada categoria base:

* B.J. King: movimento solto, combate confinado, interação agressiva
* J.P. Morgan: movimento solto, combate _melee_, interação afável
* M. Faraday: movimento rígido, combate à distância, interação rabugenta
* J. Austen: movimento gracioso, não combate, interação inteligente
* A. Frank: movimento gracioso, combate inteligente, interação afável
* M. Thatcher: movimento rígido, combate confinado, interação agressiva
* J. Reno: movimento rígido, combate confinado, interação inteligente
* J. Goodall: movimento solto, combate _melee_, interação inteligente
* A. Rand: movimento gracioso, combate confinado, interação rabugenta
* F. Kahlo: movimento gracioso, não combate, interação rabugenta
* M.L. King: movimento rígido, combate inteligente, interação inteligente
* D. Gea: movimento solto, combate à distância, interação afável
* A. Murray: movimento gracioso, combate confinado, interação agressiva
* L. Bird: movimento solto, combate à distância, interação rabugenta
* R. Polanski: movimento rígido, combate inteligente, interação inteligente
* A. Lavigne: movimento gracioso, não combate, interação afável
* K. Hammett: movimento solto, combate _melee_, interação agressiva

Responde às seguintes questões:

1. Indica, justificando, um _design pattern_ apropriado para implementar este
   sistema.
2. Apresenta um diagrama UML com a informação mínima e essencial que demonstre
   como o _design pattern_ indicado na alínea anterior pode ser utilizado para
   implementar este sistema.
3. Apresenta uma implementação muito simples em C\# deste sistema baseada na
   resposta dada nas alíneas anteriores. As "estratégias complexas" devem ser
   confinadas a simples `Console.WriteLine()`.

_Sugestão:_ Submeter soluções parciais, uma alínea de cada vez, e esperar por
_feedback_ antes de responder à alínea seguinte.

## Soluçoes

### Solução 1

1. Indica, justificando, um _design pattern_ apropriado para implementar este
   sistema.
O design pattern apropriado para fazer este ejercicio e o Strategy Pattern porque
define uma família de algoritmos, encapsula cada um deles e torna-os permutáveis.
Permite que o algoritmo mude independentemente dos clientes que o usam.

Podemos criar tantos npcs com o movemento, o combate ou a interacçao diferentes
que nos queramos sem violar o Open/Closed principle.


2. Apresenta um diagrama UML com a informação mínima e essencial que demonstre
   como o _design pattern_ indicado na alínea anterior pode ser utilizado para
   implementar este sistema.

![UML](04/Ejercicio33.jpg)


3. Apresenta uma implementação muito simples em C\# deste sistema baseada na
   resposta dada nas alíneas anteriores. As "estratégias complexas" devem ser
   confinadas a simples `Console.WriteLine()`.

   So esta provada cos NPCs B.J. King e o M.L. King as demais sao iguais so
   que mudando os metodos de dentro que neste caso e so um Console.Writeline

```cs

class Program
{
    static void Main(string[] args)
    {
        NPC[] npcs = new NPC[2];

        npcs[0] = new BJKing();
        npcs[1] = new MLKing();

        foreach(NPC npc in npcs)
        {
            ActionsNPC(npc);
        }
    }
    private static void ActionsNPC(NPC npc)
    {
        Console.WriteLine($" ===== {npc.GetType().Name} =====");
        Console.Write("\t");
        npc.Display();
        Console.Write("\t");
        npc.PerformMove();
        Console.Write("\t");
        npc.PerformCombat();
        Console.Write("\t");
        npc.PerformInteract();

    }
}

```

```cs

public abstract class NPC
{

    private IMoveBehaviour moveB;
    private ICombatBehaviour combatB;
    private IInteractBehaviour interactB;

    public IMoveBehaviour MoveB
    {
        get => moveB;
        set { if (value != null) moveB = value; }
    }

    public ICombatBehaviour CombatB
    {
        get => combatB;
        set { if (value != null) combatB = value; }
    }

    public IInteractBehaviour InteractB
    {
        get => interactB;
        set { if (value != null) interactB = value; }
    }

    public abstract void Display();

    public void PerformMove()
    {
        moveB.Move();
    }
    public void PerformCombat()
    {
        combatB.Combat();
    }

    public void PerformInteract()
    {
        interactB.Interact();
    }
}

```

```cs

public interface IMoveBehaviour
{
    void Move();
}

```

```cs

public interface ICombatBehaviour
{
    void Combat();
}

```
```cs

public interface IInteractBehaviour
{
    void Interact();
}

```

```cs

public class MovimentoSolto : IMoveBehaviour
{
    public void Move()
    {
        Console.WriteLine("Movome muito solto");
    }
}

```

```cs

public class CombateConfinado : ICombatBehaviour
{
    public void Combat()
    {
        Console.WriteLine("Combate Confinadooo");
    }
}

```
```cs

public class InteracaoAgresiva : IInteractBehaviour
{
    public void Interact()
    {
        Console.WriteLine("Sou Agresivo ¬¬");

    }
}

```
```cs

public class MovimentoRigido : IMoveBehaviour
{
    public void Move()
    {
        Console.WriteLine("Movome rigido");
    }
}

```

```cs

public class CombateInteligente : ICombatBehaviour
{
    public void Combat()
    {
        Console.WriteLine("Combate Inteligente");
    }
}

```
```cs

public class InteracaoInteligente : IInteractBehaviour
{
    public void Interact()
    {
        Console.WriteLine("Sou Inteligente");

    }
}

```

```cs

public class BJKing: NPC
{
    public BJKing()
    {
        MoveB = new MovimentoSolto();
        CombatB = new CombateConfinado();
        InteractB = new InteracaoAgresiva();
    }
    public override void Display()
    {
        Console.WriteLine("Sou B.J King");
    }
}

```

```cs

public class MLKing : NPC
{
    public MLKing()
    {
        MoveB = new MovimentoRigido();
        CombatB = new CombateInteligente();
        InteractB = new InteracaoInteligente();
    }
    public override void Display()
    {
        Console.WriteLine("Sou M.L. King");
    }
}

```

