## Problema

13 - Considera o tipos `PlayerType` e `Player`:

```cs
public enum PlayerType { Tank, Fighter, Slayer, Mage, Controller, Marksmen }
```

```cs
public class Player
{
    public PlayerType Type { get; set; }
    public string Name { get; set; }
}
```

1.  Faz _override_ dos métodos
    [`GetHashCode()`](https://docs.microsoft.com/dotnet/api/system.object.gethashcode)
    e [`Equals()`](https://docs.microsoft.com/dotnet/api/system.object.equals)
    de modo a que um jogador seja considerado único no jogo se tiver o mesmo
    tipo e o mesmo nome. Uma forma rápida de obter um _hash code_ para o tipo
    `Player` consiste em realizar a operação XOR no _hash code_ dos seus dois
    campos.
2.  Testa a tua solução colocando vários objetos do tipo `Player` num conjunto,
    repetindo propositadamente os campos de duas instâncias diferentes.
3.  Se o tipo `Player` fosse uma `struct` qual seria o comportamento por
    omissão relativamente à igualdade de instâncias? Era necessário ter feito
    os _overrides_ na primeira alínea do exercício?
    
    
## Soluções

### Solução 1

1. 

```
public override bool Equals(Object other)
{
	Player p = other as Player;

	if (p != null && p.Type == Type && p.Name == Name) return true;
		return false;
}

public override int GetHashCode()
{
	return Name.GetHashCode() ^ Type.GetHashCode();
}
```

2. 

```
Player p1 = new Player("Tracer", (PlayerType)0);
Player p2 = new Player("Warrior", (PlayerType)1);

Player p3 = new Player("Nelum", (PlayerType)5);
Player p4 = new Player("Nelum", (PlayerType)5);

//Print false
Console.WriteLine(p1.Equals(p2));
//Print True
Console.WriteLine(p3.Equals(p4));
```
            
3. Não era necessário efectuar `override` visto que iriam ser consideradas iguais
á partida. Isto deve-se ao facto de `structs` serem tipo de valor, logo os seus
campos são todos iguais (não têm referências diferentes).

*Solução proposta por [André Santos](https://github.com/Snigy24)*
